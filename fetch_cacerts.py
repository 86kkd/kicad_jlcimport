"""Fetch root CA certificates for JLCPCB/EasyEDA/LCSC endpoints.

Run this to generate the bundled cacerts.pem used by api.py for TLS
verification.  This eliminates the need for the system certificate store
(which is often broken in KiCad's bundled Python) and removes any
unverified-HTTPS fallback.

Usage:
    python -m kicad_jlcimport.fetch_cacerts
"""

import os
import socket
import ssl
import sys

# Every host the plugin connects to (see api.py).
_HOSTS = [
    "easyeda.com",
    "modules.easyeda.com",
    "jlcpcb.com",
    "lcsc.com",
    "assets.lcsc.com",
]

_OUTPUT = os.path.join(os.path.dirname(os.path.abspath(__file__)), "cacerts.pem")


def _get_root_ca_pem(hostname: str, port: int = 443) -> str:
    """Connect to *hostname* and return the root CA certificate as PEM text."""
    ctx = ssl.create_default_context()
    with ctx.wrap_socket(socket.socket(), server_hostname=hostname) as s:
        s.settimeout(10)
        s.connect((hostname, port))
        chain = s.getpeercert(binary_form=False)  # noqa: F841 â€” used for validation
        der_chain = s.get_channel_binding()  # noqa: F841
        # SSLSocket.getpeercert_chain() isn't available in stdlib;
        # fall back to openssl s_client via subprocess.
    return _get_root_pem_via_openssl(hostname, port)


def _get_root_pem_via_openssl(hostname: str, port: int = 443) -> str:
    """Use ``openssl s_client`` to retrieve the root CA PEM."""
    import subprocess

    result = subprocess.run(
        [
            "openssl",
            "s_client",
            "-connect",
            f"{hostname}:{port}",
            "-servername",
            hostname,
            "-showcerts",
        ],
        input=b"",
        capture_output=True,
        timeout=15,
    )
    stdout = result.stdout.decode("utf-8", errors="replace")
    # Extract all PEM blocks; the last one is the root CA.
    pem_blocks = []
    current: list = []
    in_block = False
    for line in stdout.splitlines():
        if "-----BEGIN CERTIFICATE-----" in line:
            in_block = True
            current = [line]
        elif "-----END CERTIFICATE-----" in line:
            current.append(line)
            pem_blocks.append("\n".join(current))
            in_block = False
        elif in_block:
            current.append(line)

    if not pem_blocks:
        raise RuntimeError(f"No certificates returned for {hostname}:{port}")
    return pem_blocks[-1]


def main() -> None:
    seen_pems: set = set()
    unique_roots: list = []

    for host in _HOSTS:
        print(f"  {host} ... ", end="", flush=True)
        try:
            pem = _get_root_ca_pem(host)
            if pem not in seen_pems:
                seen_pems.add(pem)
                unique_roots.append((host, pem))
                print("OK (new root CA)")
            else:
                print("OK (duplicate, skipped)")
        except Exception as e:
            print(f"FAILED: {e}")
            print(f"  !! Could not retrieve root CA for {host}", file=sys.stderr)
            sys.exit(1)

    with open(_OUTPUT, "w") as f:
        f.write("# Root CA certificates for JLCPCB/EasyEDA/LCSC endpoints.\n")
        f.write("# Generated by: python -m kicad_jlcimport.fetch_cacerts\n")
        f.write(f"# Hosts: {', '.join(_HOSTS)}\n\n")
        for host, pem in unique_roots:
            f.write(f"# First seen for: {host}\n")
            f.write(pem + "\n\n")

    print(f"\nWrote {len(unique_roots)} unique root CA(s) to {_OUTPUT}")


if __name__ == "__main__":
    main()
